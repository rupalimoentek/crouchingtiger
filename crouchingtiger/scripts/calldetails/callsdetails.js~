angular.module('theme.callsdetails', ['ui.select2', 'angularUtils.directives.dirPagination', "api-param"])
    .service('cfilter', ['$http', function($http) {
        'use strict';
        var cfobj = {};
        cfobj.cf = crossfilter([]);
        var ndx, all;
        $http.get('assets/demo/call_flow.json')
            .success(function(data) {
                if (data.json !== undefined) {
                    cfobj.data = data.json;
                    cfobj.ndx = cfobj.cf.add(cfobj.data);
                    cfobj.all = cfobj.ndx.groupAll();
                }
            })
            .error(function(data) {
                alert("error loading config.json");
            });

        return cfobj;
        //var idDim = cf.dimension(function(d) {
        //  return d.id;
        //});
    }])
    .factory('CallsDetailsWebService', function($q, $timeout, $http, $window, $rootScope, ApiParam) {
        'use strict';
        var CallsDetailsWebService = {};
        CallsDetailsWebService.getJsonConfig = function() {
            var config = {
                headers: {
                    'content-type': 'application/json',
                    'Authorization': 'bearer ' + $window.sessionStorage.token
                }
            };
            return config;
        };

        CallsDetailsWebService.getCallsSummaryList = function(qryStr) {
            $http.defaults.useXDomain = true;
            //if (report === 'calls-callback') { report = 'call_back'; }
            return $http.get(ApiParam.baseURL() + "/v1/report/callDetail?"+qryStr+"&count=true", ApiParam.headerConfig());
        };

        CallsDetailsWebService.getCallsDetailsList = function(qryStr) {
            $http.defaults.useXDomain = true;
            //if (report === 'calls-callback') { report = 'call_back'; }
            return $http.get(ApiParam.baseURL() + "/v1/report/callDetail?"+qryStr, ApiParam.headerConfig());
        };

        CallsDetailsWebService.getCallsDetailsInfo = function(report, userID, callID) {
            $http.defaults.useXDomain = true;
            return $http.get(ApiParam.baseURL() + "/v1/call/Info/" + callID + "/?report=" + report + "&user_id=" + userID, ApiParam.headerConfig());
        };

        CallsDetailsWebService.getCallsComments = function(report, userID, callID) {
            $http.defaults.useXDomain = true;
            return $http.get(ApiParam.baseURL() + "/v1/call/Comment/" + callID + "/?report=" + report + "&user_id=" + userID + "&timezone=" + encodeURIComponent($rootScope.timezone), ApiParam.headerConfig());
        };

        CallsDetailsWebService.setCallsComments = function(report, commentdata, userID) {
            var req = {
                method: 'POST',
                url: ApiParam.baseURL() + "/v1/call/Comment/" + "?report=" + report + "&user_id=" + userID,
                headers: ApiParam.headerConfig().headers,
                data: commentdata
            };
            return $http(req);
        };

        CallsDetailsWebService.deleteCallsComments = function(report, commentID, userID) {
            return $http.delete(ApiParam.baseURL() + "/v1/call/Comment/" + commentID + "/?report=" + report + "&user_id=" + userID, ApiParam.headerConfig());
        };

        CallsDetailsWebService.getCallsTags = function(report, userID, callID) {
            $http.defaults.useXDomain = true;
            return $http.get($rootScope.url + ":" + $rootScope.port + "/v1/call/Tag/" + callID + "/?report=" + report + "&user_id=" + userID, this.getJsonConfig());
        };

        CallsDetailsWebService.getTags = function(report, userID, callID) {
            $http.defaults.useXDomain = true;
            return $http.get($rootScope.url + ":" + $rootScope.port + "/v1/tag/ouid/" + $rootScope.currentOUId + "/userAccess/" + $rootScope.userAccess.tag + "/?report=" + report, this.getJsonConfig());
        };

        CallsDetailsWebService.setCallsTags = function(calltagdata, userID) {
            var req = {
                method: 'POST',
                url: $rootScope.url + ":" + $rootScope.port + "/v1/call/Tag/" + "?user_id=" + userID,
                headers: {
                    'content-type': 'application/json',
                    'Authorization': 'bearer ' + $window.sessionStorage.token
                },
                data: calltagdata
            };
            return $http(req);
        };

        CallsDetailsWebService.getCallBlacklist = function(report, ouID, userID) {
            $http.defaults.useXDomain = true;
            return $http.get($rootScope.url + ":" + $rootScope.port + "/v1/blacklist/ouid/" + ouID + "/" + "?report=" + report + "&user_id=" + userID, this.getJsonConfig());
        };

        CallsDetailsWebService.setCallBlacklist = function(ouID, userID, callSourceID, blockedCalls) {
            var blacklistjson = {
                "blacklist": {
                    "org_unit_id": $rootScope.currentOUId,
                    "numbers": blockedCalls
                }
            };

            var req = {
                method: 'POST',
                url: $rootScope.url + ":" + $rootScope.port + "/v1/blacklist/append",
                headers: {
                    'content-type': 'application/json',
                    'Authorization': 'bearer ' + $window.sessionStorage.token
                },
                data: blacklistjson
            };
            return $http(req);
        };

        CallsDetailsWebService.unsetCallBlacklist = function(ouID, userID, callSourceID, blockedCalls) {
            var blacklistjson = {
                "blacklist": {
                    "org_unit_id": $rootScope.currentOUId,
                    "numbers": callSourceID
                }
            };

            var req = {
                method: 'PUT',
                url: $rootScope.url + ":" + $rootScope.port + "/v1/blacklist/delete",
                headers: {
                    'content-type': 'application/json',
                    'Authorization': 'bearer ' + $window.sessionStorage.token
                },
                data: blacklistjson
            };
            return $http(req);
        };

        CallsDetailsWebService.emailRecording = function(emailData) {
            var req = {
                method: 'POST',
                url: $rootScope.url + ":" + $rootScope.port + "/v1/call/email",
                headers: {
                    'content-type': 'application/json',
                    'Authorization': 'bearer ' + $window.sessionStorage.token
                },
                data: emailData
            };
            return $http(req);
        };

        return CallsDetailsWebService;
    })

.controller('CallsDetailsController', ['$scope', '$http', '$window', '$rootScope', '$routeParams', 'CallsDetailsWebService', 'pinesNotifications', '$timeout', '$compile', '$q', '$bootbox', '$uibModal', '$location', 'DateRangeFiller', 'advFilSrvc',
        function($scope, $http, $window, $rootScope, $routeParams, CallsDetailsWebService, pinesNotifications, $timeout, $compile, $q, $bootbox, $uibModal, $location, DateRangeFiller, advFilSrvc) {

			$scope.simpleSearchFilter =  "";
            $scope.filterApplied = false;
			$scope.horsemanFlag = false;
			$scope.hideDataTable = false;
			$scope.hidePaginationControls = false;
            $scope.roleId = $rootScope.roleId;
            $scope.currentPage = 1;
            $scope.report = ($location.search().report ? $location.search().report : 'call_detail');
            $scope.pageSize = 100;
            $scope.showme = [];
            $scope.actionHeader = ['Actions'];
            $scope.callbackHeader = ['Date/Time', 'Group Name', 'Campaign', 'Ad Source', 'Caller ID', 'Tracking No.', 'Destination Name | No.', 'Duration'];
            $scope.callDetailsHeader = ['Date/Time', 'Group Name', 'Campaign', 'Ad Source', 'Caller ID', 'Tracking No.', 'Destination Name | No.', 'Duration'];
            $scope.pagination = { current: ($routeParams.page ? $routeParams.page : 1) };

            $scope.preview = ($location.search().preview ? $location.search().preview : false);
            if ($location.search().preview) {
                $("#wrap").append('<div id="previewBlock">&nbsp;</div>');
            }

            console.log('REPORT', $scope.report);

            $scope.drp_options = {
                ranges:    {
                    'Today':        [moment().startOf('day'),                                       moment().endOf('day')],
                    'Yesterday':    [moment().subtract(1, 'days').startOf('day'),                   moment().subtract(1, 'days').endOf('day')],
                    'Last 7 Days':  [moment().subtract(7, 'days').startOf('day'),                   moment().endOf('day')],
                    'Last 30 Days': [moment().subtract(30, 'days').startOf('day'),                  moment().endOf('day')],
                    'This Month':   [moment().startOf('month').startOf('day'),                      moment().endOf('month').endOf('day')],
                    'Last Month':   [moment().subtract(1, 'month').startOf('month').startOf('day'), moment().subtract(1, 'month').endOf('month').endOf('day')]
                },
                opens:     'left',
                startDate: moment().subtract(7, 'days').startOf('day'),
                endDate:   moment().endOf('day')
            };

			// Set datepicker on load
			if ($window.sessionStorage.report_start_date) {
				$scope.drp_start = moment($window.sessionStorage.report_start_date).format('MMMM D, YYYY');
			} else {
				$scope.drp_start = $scope.drp_options.ranges['Last 7 Days'][0].format('MMMM D, YYYY');
			}
			if ($window.sessionStorage.report_end_date) {
				$scope.drp_end = moment($window.sessionStorage.report_end_date).format('MMMM D, YYYY');
			} else {
				$scope.drp_end = $scope.drp_options.ranges['Last 7 Days'][1].format('MMMM D, YYYY');
			}
			$scope.drp_options.startDate = moment($scope.drp_start);
			$scope.drp_options.endDate = moment($scope.drp_end);
            console.log('DRP_OPTIONS', $scope.drp_options);

			$scope.paginateHeaderTemp = null;
			$scope.summaryItemsTemp = null;

            $scope.loadReportBasedOnQueryString = function() {
				console.log('INSIDE loadReportBasedOnQueryString IN callsdetails.js: Loading report with urlParams:', $scope.urlParams);
                $scope.paginateHeader = 'Loading Data...';

                CallsDetailsWebService.getCallsSummaryList($.param($scope.urlParams)).then(function(result) {
                    if (result.data.json !== undefined) {
						console.log('INSIDE CallsDetailsWebService.getCallsSummaryList IN callsdetails.js: Data found', result.data.json);
                        if (result.data.json.length > 0) {

                            var dataSet = result.data.json;
                            _.each(dataSet, function(data) {
                                data.singlerec = 1;
                                data.average_durationHHMMSS = 	moment.utc(parseInt(data.average_duration_calls) * 1000);
                                data.total_durationHHMMSS = 	moment.utc(parseInt(data.total_duration_calls) * 1000);
                                data.average_durationHH = 		data.average_durationHHMMSS.hours();
                                data.average_durationMM = 		data.average_durationHHMMSS.minutes();
                                data.average_durationSS = 		data.average_durationHHMMSS.seconds();
                                data.total_durationHH = 		data.total_durationHHMMSS.hours();
                                data.total_durationMM = 		data.total_durationHHMMSS.minutes();
                                data.total_durationSS = 		data.total_durationHHMMSS.seconds();
                            });
                            $scope.summaryItemsTemp = dataSet;
                            var headerString = 'Showing ';
                            if ($scope.pagination.current > 1) {
                                headerString = headerString + ' ' + (($scope.pageSize * ($scope.pagination.current - 1)) + 1) + ' - ';
                            } else {
                                headerString = headerString + ' ' + $scope.pagination.current + ' - ';
                            }
                            if (($scope.pageSize * $scope.pagination.current) > $scope.summaryItemsTemp[0].total_count_calls) {
                                headerString = headerString + ' ' + $scope.summaryItemsTemp[0].total_count_calls + ' of ' + $scope.summaryItemsTemp[0].total_count_calls;
                            } else {
                                headerString = headerString + ' ' + ($scope.pageSize * $scope.pagination.current) + ' of ' + $scope.summaryItemsTemp[0].total_count_calls;
                            }
                            if ($scope.summaryItemsTemp[0].total_count_calls > 0) {
                                $scope.paginateHeaderTemp = headerString;
                            } else {
                                $scope.paginateHeaderTemp = 'No Data Found';
                            }
                        } else {
                            $scope.paginateHeaderTemp = 'No Data Found';
                            console.log('No returned result data');
                        }
                    } else {
                        $scope.paginateHeaderTemp = 'No Result';
                        console.log('No result data');
                    }
                });

				console.log('INSIDE loadReportBasedOnQueryString IN callsdetails.js: About to fire getCallsDetailsList');

                CallsDetailsWebService.getCallsDetailsList($.param($scope.urlParams)).then(function(result) {
                    if (result.data.json === undefined) {
                        console.log('INSIDE CallsDetailsWebService.getCallsDetailsList IN callsdetails.js: Returning false');
                        return false;
                    } else if (result.data.json.length > 0) {
						console.log('INSIDE CallsDetailsWebService.getCallsDetailsList IN callsdetails.js: Data found');
                        var dataSet = result.data.json;
                        var timeFormat2 = d3.time.format('%Y-%m-%dT%H:%M:%S.%LZ');

                        _.each(dataSet, function(data) {
                            data.d3_date = timeFormat2.parse(data.call_started);
                            //data.call_start_date = moment(data.call_started, "YYYY-MM-DD").format("MM-DD-YYYY h:mm:ss a");
                            data.call_start_date = moment.utc(data.call_started).format("MM-DD-YYYY h:mm:ss a");
                            data.singlerec = 1;
                            data.blocktext = "Block";
                            data.blockclass      = 'btn-danger';
                            data.showinfo = false;
                            data.durationHHMMSS = moment.utc(parseInt(data.duration) * 1000).format('HH:mm:ss');
                            data.noRecording = false;
                            data.listenLabel = "Listen to call";
                            if (data.recording_file === null || data.recording_file === '') {
                                data.noRecording = true;
                                data.listenLabel = "No recording for this call";
                            }
                        });

                        // console.log('INSIDE CallsDetailsWebService.getCallsDetailsList IN callsdetails.js: Setting items', dataSet);
                        $scope.items = dataSet;
                        $scope.xf1 = crossfilter(dataSet);
                        $scope.dc1 = dc;
                        for (var i = 0; i < dataSet.length; i++) {
                            $scope.showme[i] = false;
                        }

                        CallsDetailsWebService.getCallBlacklist($scope.call_report, $rootScope.currentOUId, $rootScope.userId).then(function(result) {
                            var dataSet = result.data.json;
                            if (dataSet !== undefined && dataSet.length > 0) { $scope.blocked_calls = dataSet; }

                            if ($scope.blocked_calls !== undefined) {
                                _.each($scope.items, function(data) {
                                    var isBlocked = -1;

                                    //test for valid caller id 'source'
                                    if (data.source.length > 1 && data.source !== "0") { isBlocked = $scope.blocked_calls.search(data.source); }
                                    //found
                                    if (isBlocked > -1) { //Currently Blocked
                                        data.blocktext = "Unblock";
                                        data.blockclass = 'btn-danger-alt';
                                    } else { //not found - Currently Unblocked
                                        data.blocktext = "Block";
                                        data.blockclass = 'btn-danger';
                                    }
                                }, $scope.blocked_calls);
                            }
                        });
                    } else {
                        console.log('INSIDE CallsDetailsWebService.getCallsDetailsList IN callsdetails.js: The length of the results is 0.');
						$scope.items = [];
                    }


					$scope.hideDataTable = false;
					$scope.hidePaginationControls = false;
					$scope.summaryitems = $scope.summaryItemsTemp;
					$scope.paginateHeader = $scope.paginateHeaderTemp;
					setTimeout(function() {
						$scope.horsemanFlag = true;
					}, 1000);

					if ($scope.showAdvFilter === true && $scope.advFilterDefinitions.length > 0) {
						if ($scope.advFilterDefinitions[0].user_input || $scope.advFilterDefinitions[0].user_input === 0) {
							$scope.filterApplied = true;
						}
					} else if ($scope.simpleSearchFilter.length > 0) {
						$scope.filterApplied = true;
					}
                });
            };

            // Send scope to advanced filter directive
            /*$scope.$on('request_scope', function() {
                console.log("INSIDE 'request_scope' IN callsdetails.js: Broadcasting 'receive_scope'");
                $rootScope.$broadcast('receive_scope', $scope);
            });

            // return from determineReportQueryParams
            $scope.$on('return_url_params', function(e, urlParams) {
                console.log('INSIDE return_url_params IN callsdetails.js: Received filter params:', urlParams);
                $scope.urlParams = urlParams.vars;
                delete urlParams.vars;
                angular.extend($scope, urlParams);
            });
            */

            $scope.redirectScheduledEditor = function(whichReport) {
                $scope.applyFilterParams();
                $scope.loadReportBasedOnQueryString();
                //determineReportQueryParams();
                //$location.url($location.path()+'?'+$.param($scope.urlParams));
            };

            $scope.pageChanged = function(newPage) {
				console.log('PAGE CHANGED');
                $scope.offset = ($scope.pageSize * ($scope.pagination.current - 1));
                $scope.applyFilter();
            };

            $scope.resizeWindow = function() {
                setTimeout(function() {
                    $(window).trigger('resize');
                }, 100);
            };

            $("[data-collapse-group='infoShow']").click(function() {
                var $this = $(this);
                $("[data-collapse-group='infoShow']:not([data-target='" + $this.data("target") + "'])").each(function() {
                    $($(this).data("target"))
                        .removeClass("in")
                        .addClass('collapse');
                });
            });

            $scope.call_report = $window.document.URL.split("/");
            $scope.call_report = $scope.call_report[$scope.call_report.length - 1];
            $scope.call_report = $scope.call_report.split("?")[0];

            if ($scope.call_report === "calls-details") {
                $scope.call_report = 'call_detail';
            } else if ($scope.call_report === "calls-callback") {
                $scope.call_report = 'call_back';
            } else {
                console.log('Bad call_report value for $scope.call_report');
            }
            // console.log('CALL_REPORT', $scope.call_report);

            $scope.comment = {};
            $scope.comment.text = [];

            $scope.isReadonly = false;
            $scope.isTagAccess = true;

            if ($scope.userAccess && ($scope.userAccess.campaign === undefined || $scope.userAccess.campaign < 5)) {
                $scope.isReadonly = true;
            }
            if ($scope.userAccess && ($scope.userAccess.tag < 5 || $scope.userAccess.tag === undefined)) {
                $scope.isTagAccess = false;
            }

            $scope.getCSVData = function() {
                //var urlParams = determineReportQueryParams();
                $scope.urlParams.exportData = true;
                $scope.urlParams.limit = 100000;
                $scope.csvHeaderNames = ["Call ID", "Date/Time", "Group Name", "Campaign", "Ad Source", "Caller ID", "Tracking No.", "Destination Name | No.", "Duration"];

                var calldetailsData = [];
                if ($scope.summaryitems[0].total_count_calls > 100000) {
                    $bootbox.alert("Your export will be capped at the maximum number of 100,000 records.");
                    $scope.urlParams.limit = 100000;
                }
                var deferred = $q.defer(); //promise

                CallsDetailsWebService.getCallsDetailsList($.param($scope.urlParams)).then(function(result) {
                    if (result.data.json.length > 0) {
                        var dataSet = result.data.json;
                        var timeFormat2 = d3.time.format('%Y-%m-%dT%H:%M:%S.%LZ');

                        for (var i = 0; i < dataSet.length; i++) {
                            var dest = dataSet[i].ring_to_name + " | " + dataSet[i].ring_to;
                            calldetailsData.push({
                                a: dataSet[i].call_id,
                                b: dataSet[i].call_start_date = moment.utc(dataSet[i].call_started).format("MM-DD-YYYY h:mm:ss a"),
                                c: dataSet[i].org_unit_name,
                                d: dataSet[i].campaign_name,
                                e: dataSet[i].category + ":" + dataSet[i].sub_category,
                                f: dataSet[i].source,
                                g: dataSet[i].tracking,
                                h: dest,
                                i: dataSet[i].duration
                            });
                        }
                    }
                    deferred.resolve(calldetailsData);
                });
                return deferred.promise;
            };

            $scope.getCSVDataReports = function() {
                //var urlParams = determineReportQueryParams();
                $scope.urlParams.exportData = true;
                $scope.urlParams.limit = 50000;

                $scope.csvHeaderNames = ["Call ID", "Date/Time", "Group Name", "Campaign", "Ad Source", "Caller ID", "Tracking No.", "Destination Name | No.", "Duration", "Audio File"];

                var calldetailsDataReport = [];
                // if ($scope.summaryitems[0].total_count_calls > 50000) {
                //     $bootbox.alert("Your export will be capped at the maximum number of 100,000 records.");
                //     $scope.urlParams.limit = 50000;
                // }
                var deferred = $q.defer(); //promise

                CallsDetailsWebService.getCallsDetailsList($.param($scope.urlParams)).then(function(result) {
                    if (result.data.json.length > 0) {
                        var dataSet = result.data.json;

                        for (var i = 0; i < dataSet.length; i++) {
                            var dest = dataSet[i].ring_to_name + " | " + dataSet[i].ring_to;
                            calldetailsDataReport.push({
                                "Call ID": dataSet[i].call_id,
                                "Date/Time": dataSet[i].call_start_date = moment.utc(dataSet[i].call_started).format("MM-DD-YYYY h:mm:ss a"),
                                "Group Name": dataSet[i].org_unit_name,
                                "Campaign": dataSet[i].campaign_name,
                                "Ad Source": dataSet[i].category + ":" + dataSet[i].sub_category,
                                "Caller ID": dataSet[i].source,
                                "Tracking No.": dataSet[i].tracking,
                                "Destination Name | No.": dest,
                                "Duration": dataSet[i].duration,
                                "Audio File": dataSet[i].s3URL
                            });
                        }
                    }
                    deferred.resolve(calldetailsDataReport);
                    $scope.csvDataScheduleReport = calldetailsDataReport;
                });
                return deferred.promise;
            };

            $scope.exportPDF = function() {

                var pdf = new jsPDF('l', 'pt', 'legal');
                var options = {
                    pagesplit: true
                };
                pdf.addHTML($("#callsData"), options, function() {
                    var string = pdf.output('datauristring');
                    //$('.preview-pane').attr('src', string);
                    setTimeout(function() {
                        pdf.save('calls-details.pdf');
                        //     $(".buttons").show();
                    }, 100);
                });
            };

            $scope.call_tags = [];
            $scope.selCallTags = {};
            $scope.call_tagslength = [];

            var internalMappedNames = {};

            // reference keys on the aggregated data objects
            internalMappedNames.aggregate_property_keys = {
                call_id: "call_id",
                date_time: "call_started",
                group_name: "org_unit_name",
                campaign: "campaign_name",
                channel: "category",
                subchannel: "sub_category",
                caller_id: "caller_id",
                tracking_nbr: "tracking",
                dest_name: "ring_to_name",
                dest_nbr: "ring_to",
                duration: "duration"
            };

            // values displayed at top of columns
            internalMappedNames.dataTableHeaderValues = {
                call_id: "Call ID",
                date_time: "Date/Time",
                group_name: "Group Name",
                campaign: "Campaign",
                channel: "Ad Source",
                subchannel: "Sub Channel",
                caller_id: "Caller ID",
                tracking_nbr: "Tracking No.",
                dest_name: "Destination Name",
                dest_nbr: "No.",
                duration: "Duration"
            };

            function createHeaderValueToAggKeyName() {
                var headerValues = internalMappedNames.dataTableHeaderValues;
                var aggKeyNames = internalMappedNames.aggregate_property_keys;


                var headerValueToAggKeyName = {};
                headerValueToAggKeyName[headerValues.call_id] = aggKeyNames.call_id;
                headerValueToAggKeyName[headerValues.date_time] = aggKeyNames.date_time;
                headerValueToAggKeyName[headerValues.group_name] = aggKeyNames.group_name;
                headerValueToAggKeyName[headerValues.campaign] = aggKeyNames.campaign;
                headerValueToAggKeyName[headerValues.channel] = aggKeyNames.channel;
                headerValueToAggKeyName[headerValues.subchannel] = aggKeyNames.subchannel;
                headerValueToAggKeyName[headerValues.caller_id] = aggKeyNames.caller_id;
                headerValueToAggKeyName[headerValues.tracking_nbr] = aggKeyNames.tracking_nbr;
                headerValueToAggKeyName[headerValues.dest_name] = aggKeyNames.dest_name;
                headerValueToAggKeyName[headerValues.dest_nbr] = aggKeyNames.dest_nbr;
                headerValueToAggKeyName[headerValues.duration] = aggKeyNames.duration;

                return headerValueToAggKeyName;
            }

            function getDataGridHeaderValues() {
                var dataTableHVs = internalMappedNames.dataTableHeaderValues;

                var valuesToDisplayInDataGridHeaders = [

                    // These can be manually added in since they're static
                    dataTableHVs.call_id,
                    dataTableHVs.date_time,
                    dataTableHVs.group_name,
                    dataTableHVs.campaign,
                    dataTableHVs.channel,
                    dataTableHVs.caller_id,
                    dataTableHVs.tracking_nbr,
                    dataTableHVs.dest_name + "|" + dataTableHVs.dest_nbr,
                    dataTableHVs.duration
                ];

                // array of string names of the header values that go at the top of the data grid
                return valuesToDisplayInDataGridHeaders;
            }

            //$scope.advFiltersAreApplied = false;
            $scope.simpleSearchApplied = true;
            $scope.simpleSearchPlaceholder = '';

            function determineReportQueryParams() {
                $scope.applyFilterParams();
                //$scope.urlParams = {};
                //$rootScope.$broadcast('start_url_assembly', 'blank');

				// Update pagination header -- DON'T STOMP ME
				setTimeout(function() {
					var offset = ($location.search().offset !== undefined) ? parseInt($location.search().offset) : 0;
					$scope.pagination.current = (parseInt(offset / 100) + 1);
					return $scope.urlParams;
				}, 1000);
            }

            // Scope methods used when user uses filter that requires a new data-set from backend
            $scope.changeDateRange = function() {
                $scope.filterReset();
				$window.sessionStorage.report_start_date = $scope.drp_start;
				$window.sessionStorage.report_end_date = $scope.drp_end;
                $scope.offset = 0;
                $scope.pagination.current = 1;
				$scope.horsemanFlag = false;
				$scope.filterApplied = false;
                $scope.applyFilter();
            };

            $scope.changeReportParams = function(paramTypeToChange) {
                $scope.applyFilterParams();
                //determineReportQueryParams();
            };

            $scope.call_commentslength = [];
            $scope.call_comments = [];
            $scope.getcallcomments = function(userID, callID) {

                CallsDetailsWebService.getCallsComments($scope.call_report, userID, callID).then(function(result) {
                    var dataSet = result.data.json;

                    _.each(dataSet, function(data) {

                        data.comment_created_formatted = moment(data.comment_created).format("MM-DD-YYYY h:mm:ss a");
                        data.singlerec = 1;
                    });
                    $scope.call_id = callID;
                    $scope.call_comments[callID] = _.filter(dataSet, function(data) {
                        return data.comment_parent_id === null;
                    });
                    $scope.call_commentslength[callID] = ($scope.call_comments[callID] !== undefined) ? $scope.call_comments[callID].length : 0;

                    $scope.call_responses = _.filter(dataSet, function(data) {
                        return data.comment_parent_id !== null;
                    });
                    $scope.call_responseslength = ($scope.call_responses !== undefined) ? $scope.call_responses.length : 0;
                });
            };

            $scope.getcalltags = function(userID, callID) {

                CallsDetailsWebService.getCallsTags($scope.call_report, $rootScope.userId, callID).then(function(result) {

                    var dataSet = result.data.json;
                    selectedCallTags = [];

                    if (dataSet !== undefined) {
                        _.each(dataSet, function(data) {
                            data.singlerec = 1;
                            var o = {};
                            o.id = data.tag_id;
                            o.text = data.tag_name;
                            selectedCallTags.push(o.id);
                            if (data.permission > $scope.userAccess.tag) {
                                data.locked = 'locked';
                            }
                        });
                        $scope.selCallTags[callID] = selectedCallTags;
                        $scope.call_id = callID;
                        $scope.call_tagslength[callID] = dataSet.length;
                        $scope.call_tags[callID] = dataSet;
                    }
                    CallsDetailsWebService.getTags($scope.call_report, $rootScope.userId, callID).then(function(result) {
                        var dataSet = result.data.json;
                        //console.log(dataSet);
                        $scope.selTags = [];
                        if (dataSet !== undefined) {
                            _.each(dataSet, function(data) {
                                data.singlerec = 1;
                                $scope.selTags.push(data.tag_id);
                                //replacing line below that assigns dataSet to $scope.tags.
                                $('#calltagselect' + callID).append('<option value="' + data.tag_id + '" >' + data.tag_name + '</option>');
                            });
                            $scope.call_id = callID;
                            $scope.tagslength = dataSet.length;

                            //$scope.tags = dataSet; //way too slow to assign this much data to a scope variable that is being used in an ngrepeat
                        }
                    });
                });
            };
            $scope.ind_scores = [];
            $scope.dnidata = [];
            $scope.caller_info = [];
            $scope.getinfodetails = function(index, callID, showStatus) {
                if (showStatus) {
                    //$scope.hasExtendedData = false;
                    CallsDetailsWebService.getCallsDetailsInfo($scope.call_report, $rootScope.userId, callID).then(function(result) {
                        var dataSet = result.data.json;
                        //console.log(dataSet);
                        var dni = dataSet[0].dni;
                        var dnilength = dni.length;

                        var source_data = dataSet[0].source_data;
                        var source_datalength = source_data.length;

                        var indicator_scores = dataSet[0].indicator_scores;

                        var indicator_scoreslength = indicator_scores.length;

                        _.each(dataSet, function(data) {
                            data.singlerec = 1;
                        });
                        if (dataSet[0] !== undefined) {
                            if (source_datalength > 0) {
                                $scope.hasExtendedData = true;
                                if (source_data[0].call_data === 'NoInfo') {
                                    $scope.caller_info[index] = {
                                        'consumer1': {
                                            'first_name': 'No Information'
                                        }
                                    };
                                } else {
                                    $scope.caller_info[index] = source_data[0].call_data.reverse_phone_append;
                                }
                            } else {
                                $scope.hasExtendedData = false;
                            }
                            if (indicator_scoreslength > 0) {
                                //console.log(indicator_scores);

                                $scope.ind_scores[index] = [];
                                //create array of ind scores keyed by indicator name
                                //console.log('index: '+index);
                                for (var key in indicator_scores) {
                                    $scope.ind_scores[index][indicator_scores[key].indicator_name] = indicator_scores[key].score_value;
                                }

                                //console.log($scope.ind_scores);
                            }
                            if (dnilength > 0) {
                                if (dni[0].data !== undefined) {
                                    $scope.dnidata[index] = dataSet[0].dni[0].data;

                                    // Base URL regex since referring is a messy long link with all its query strings attached
                                    var baseUrl = $scope.dnidata[index].referring.match(new RegExp(".+?[^\/:](?=[?\/]|$)"));

                                    // Javascript RE will return null if no matches, otherwise it's an array of grouping matches
                                    if (baseUrl !== null) {
                                        $scope.dnidata[index].referring = baseUrl[0];
                                    }
                                }
                            }
                        }

                    });

                    //Get the Call Comments
                    $scope.getcallcomments($rootScope.userId, callID);

                    //Get the Call Tags
                    $scope.call_tagslength[callID] = '';
                    $scope.call_tags[callID] = [];
                    $scope.getcalltags($rootScope.userId, callID);
                } else {
                    $scope.comment.text = [];
                }

            };

            $scope.tagoptiontemplate = function(actionId) {
                var options = {
                    formatNoMatches: function(term) {
                        $scope.actionId = actionId;
                        //console.log($scope);
                        var message = "";
                        //term = term.trim();
                        if (term !== '') {
                            message = '<a ng-href="#" ng-click="postcalltag($index, item.call_id, false);">Add tag:"' + term.trim() + '"</a>';
                            if (!$scope.$$phase) {
                                $scope.$apply(function() {
                                    $scope.noResultsTag = term;
                                });
                            }
                        } else {
                            message = "";
                        }
                        return message;
                    },
                    //handle for prepending an option on keyup
                    sortResults: function(results, container, query) {
                        var found = false;
                        query.term = query.term.trim();
                        if (query.term.length > 0) {
                            for (var x in results) {
                                //console.log('Term:'+query.term+'--Result:'+results[x].text);
                                if (query.term.trim() == results[x].text.trim()) {
                                    found = true;
                                    break;
                                }
                            }
                            //add option to top of the list of results
                            if (!found) $('.select2-results').prepend('<li class="select2-no-results"><a ng-href="#" ng-click="postcalltag($index, item.call_id, false);">Add tag:"' + query.term + '"</a></li>');
                            //compile the new html in angular to get it to evaluate the new ng-click
                            if (!$scope.$$phase) {
                                $scope.$apply(function() {
                                    $scope.noResultsTag = query.term;
                                });
                            }
                        }
                        //return list unchanged
                        return results;
                    },
                    simple_tags: true,
                    allowClear: true
                };
                return options;
            };


            $scope.postcalltag = function(index, callID, multiple) {
                var calltagjson = {};
                var calltags = [];
                calltagjson.addmultiple = multiple;
                calltagjson.call_id = $scope.call_id;
                calltagjson.ct_user_id = $rootScope.userId;
                calltagjson.currentOUId = $rootScope.currentOUId;

                if (multiple) {
                    // Add multiple tags
                    currentTags = $('#calltagselect' + callID).select2("data");

                    _.each(currentTags, function(tagdata, index) {
                        calltags.push({
                            "tag": {
                                "call_id": $scope.call_id,
                                "ct_user_id": $rootScope.userId,
                                "org_unit_id": $rootScope.currentOUId,
                                "tag_id": parseInt(currentTags[index].id),
                                "tag_text": currentTags[index].text.trim(),
                                "tag_created": null
                            }
                        });
                    });

                    calltagjson.calltags = calltags;

                    CallsDetailsWebService.setCallsTags(calltagjson, $rootScope.userId).then(function(result) {
                        var dataSet = result.data.json;
                        if (result.data.err === '') {
                            pinesNotifications.notify({
                                title: 'Update Call Tags',
                                text: 'Successfully updated call tags',
                                type: 'success'
                            });

                            $scope.call_tagslength[callID] = calltags.length;
                            // $scope.getcalltags($rootScope.userId, result.config.data.call_id);

                        } else {
                            pinesNotifications.notify({
                                title: 'Update Call Tags',
                                text: result.data.err,
                                type: 'error'
                            });
                        }
                        return;
                    });
                } else {

                    var duplicateTags = _.where($scope.tags, {
                        tag_name: (this.noResultsTag).trim()
                    });
                    if (duplicateTags.length > 0) {
                        pinesNotifications.notify({
                            title: 'Update Call Tags',
                            text: 'This Tag already exists',
                            type: 'error'
                        });
                        return false;
                    }
                    calltags.push({
                        "tag": {
                            "call_id": this.call_id,
                            "ct_user_id": $rootScope.userId,
                            "org_unit_id": $rootScope.currentOUId,
                            "tag_id": null,
                            "tag_text": this.noResultsTag.trim(),
                            "tag_created": null
                        }
                    });

                    calltagjson.calltags = calltags;

                    CallsDetailsWebService.setCallsTags(calltagjson, $rootScope.userId).then(function(result) {
                        var dataSet = result.data.json;
                        if (result.data.err === '') {
                            pinesNotifications.notify({
                                title: 'Update Call Tags',
                                text: 'Successfully added call tag',
                                type: 'success'
                            });
                            //Get the Call Tags
                            currentTags = $('#calltagselect' + $scope.call_id).select2("data");
                            var selectedCallTags = [];
                            var calTagDataSet = [];
                            _.each(currentTags, function(data) {
                                data.singlerec = 1;
                                selectedCallTags.push(data.id);
                                calTagDataSet.push({
                                    "call_id": $scope.call_id,
                                    "tag_id": data.id,
                                    "tag_name": data.text,
                                    "locked": (data.locked ? "locked" : "unlocked")
                                });
                            });
                            selectedCallTags.push(dataSet.tag_id);
                            calTagDataSet.push({
                                "call_id": $scope.call_id,
                                "tag_id": dataSet.tag_id,
                                "tag_name": dataSet.tag_name,
                                "locked": false
                            });

                            $scope.selCallTags[$scope.call_id] = selectedCallTags;
                            $scope.call_tagslength[$scope.call_id] = calTagDataSet.length;
                            $scope.call_tags[$scope.call_id] = calTagDataSet;

                            //$scope.getcalltags($rootScope.userId, result.config.data.call_id);
                        } else {
                            pinesNotifications.notify({
                                title: 'Update Comments',
                                text: result.data.err,
                                type: 'error'
                            });
                        }
                        return;
                    });
                }
            };

            $scope.$watch('call_tags[$scope.call_id]', function(newVal, oldVal) {
                $timeout(function() {
                    //console.log("selCallTags: " + JSON.stringify($scope.selCallTags));
                    if (!angular.isUndefined($scope.selCallTags[$scope.call_id]) && $scope.call_tags[$scope.call_id].length > 0) {
                        var noResultsLink = $('.select2-drop');
                        noResultsLink.hide();
                        var testthis = $('select2-container .select2-choices');
                        testthis.append('<li class="select2-search-choice"><div>' + $scope.call_tags[$scope.call_id][$scope.call_tags[$scope.call_id].length - 1].tag_name.toString() + '<div><a href="#" class="select2-search-choice-close" tabindex="-1"></a></li>');
                    }
                });
            }, true);

            $scope.$watch('noResultsTag', function(newVal, oldVal) {
                if (newVal && newVal !== oldVal) {
                    $timeout(function() {
                        var noResultsLink = $('.select2-no-results');
                        // console.log(noResultsLink.contents());
                        $compile(noResultsLink.contents())($scope);
                    });
                }
            }, true);

            $scope.postcomment = function(index, callid) {
                var callcommentjson = {
                    "comment": {
                        "call_id": callid,
                        "ct_user_id": $rootScope.userId,
                        "comment_text": $scope.comment.text[callid],
                        "comment_created": null,
                        "comment_modified": null,
                        "comment_parent_id": null,
                        "comment_active": true
                    }
                };

                CallsDetailsWebService.setCallsComments($scope.call_report, callcommentjson, $rootScope.userId).then(function(result) {
                    var dataSet = result.data.json;
                    if (result.data.err === '') {
                        pinesNotifications.notify({
                            title: 'Update Comments',
                            text: 'Successfully added comment',
                            type: 'success'
                        });

                        //Get the Call Comments
                        $scope.comment.text[callid] = "";
                        $scope.getcallcomments($rootScope.userId, callid);

                    } else {
                        pinesNotifications.notify({
                            title: 'Update Comments',
                            text: result.data.err,
                            type: 'error'
                        });
                    }
                    return;
                });
            };


            $scope.userCanDeleteComment = function(comment_user_id) {
                if (!$scope.isReadonly) {
                    return true;
                } else {
                    // if they are a readonly user, then only allow user to delete comment if it is his/her own
                    return parseInt($rootScope.userId) === comment_user_id;
                }
            };

            $scope.deletecomment = function(index, commentid, callID) {

                CallsDetailsWebService.deleteCallsComments($scope.call_report, commentid, $rootScope.userId).then(function(result) {
                    var dataSet = result.data.json;
                    if (result.data.err === '') {
                        pinesNotifications.notify({
                            title: 'Delete Comments',
                            text: 'Successfully deleted comment',
                            type: 'success'
                        });

                        //Get the Call Comments
                        $scope.getcallcomments($rootScope.userId, callID);

                    } else {
                        pinesNotifications.notify({
                            title: 'Delete Comments',
                            text: result.data.err,
                            type: 'error'
                        });
                    }
                    return;
                });
            };


                    $scope.blocknumber = function(index, callsourceid) {
                        console.log("callsourceid: " + callsourceid);
                        if (callsourceid !== "0" && callsourceid !== ""){
                            CallsDetailsWebService.getCallBlacklist($scope.report, $rootScope.currentOUId, $rootScope.userId).then( function (result) {
                                var dataSet = result.data.json;

                                if (dataSet.length > 0) {
                                    $scope.blocked_calls = dataSet;
                                }
                                else {
                                    $scope.blocked_calls = "";
                                }

                                var blockedcalls = $scope.blocked_calls;
                                console.log("Blocked Calls: " + blockedcalls);
                                var n = blockedcalls.search(callsourceid);

                                if($scope.items[index].blocktext === "Block"){
                                    //Blacklist the number
                                    if (n > -1){
                                        //already added to blacklist
                                        pinesNotifications.notify({
                                            title: 'Block Number',
                                            text: 'Already added Caller ID to blacklist',
                                            type: 'fail'
                                        });
                                        return true;
                                    }
                                    else{
                                        //need to add to blacklist
                                        // check if there is no number in blacklist, prevent from sending invalid number.
                                        if(blockedcalls !== "" && blockedcalls !== undefined)
                                        blockedcalls = callsourceid.concat("," + blockedcalls);
                                        else
                                            blockedcalls = callsourceid;
                                        $scope.blocked_calls = blockedcalls;

                                        CallsDetailsWebService.setCallBlacklist($rootScope.currentOUId, $rootScope.userId, callsourceid, blockedcalls).then( function (result) {
                                            var blockresult = result;
                                            if (blockresult !== undefined) {
                                                _.each($scope.items, function (data) {
                                                    if (data.source === callsourceid) {
                                                        data.blocktext = "Unblock";
                                                        data.blockclass = "btn-danger-alt";
                                                        data.blockme = false;
                                                    }
                                                }, callsourceid);
                                                pinesNotifications.notify({
                                                    title: 'Block Number',
                                                    text: 'Successfully blacklisted Caller ID',
                                                    type: 'success'
                                                });
                                            }
                                            else {
                                                pinesNotifications.notify({
                                                    title: 'Block Number',
                                                    text: 'Failed to blacklist Caller ID',
                                                    type: 'fail'
                                                });
                                            }
                                        });
                                        return false;
                                    }
                                }
                                else{
                                    //Remove the number from Blacklist
                                    if (n > -1){
                                        //need to remove from blacklist;
                                        CallsDetailsWebService.unsetCallBlacklist($rootScope.currentOUId, $rootScope.userId, callsourceid, blockedcalls).then( function (result) {
                                            var blockresult = result;
                                            if (blockresult !== undefined) {
                                            _.each($scope.items, function (data) {
                                                if (data.source === callsourceid) {
                                                    data.blocktext = "Block";
                                                    data.blockclass = "btn-danger";
                                                    data.blockme = false;
                                                }
                                            }, callsourceid);

                                            pinesNotifications.notify({
                                                title: 'Unblock Number',
                                                text: 'Successfully removed Caller ID from blacklist',
                                                type: 'success'
                                            });
                                            }
                                            else {
                                                pinesNotifications.notify({
                                                    title: 'Unblock Number',
                                                    text: 'Failed to remove Caller ID from blacklist',
                                                    type: 'fail'
                                                });
                                            }
                                        });
                                        return true;
                                    }
                                    else{
                                        //already removed from blacklist;
                                        pinesNotifications.notify({
                                            title: 'Unblock Number',
                                            text: 'Already removed Caller ID from blacklist',
                                            type: 'fail'
                                        });
                                        return false;
                                    }
                                }
                            });
                        }
                    };

            /////////////////////////
            //Filter Section
            /////////////////////////
            $scope.updateSimpleFilter = function(cleanUpDS) {
                //if adv filters are applied, always update $scope.dataTableValues with dcfilters && advFilters
                // otherwise, only update the $scope.dataTableValues with dcfilters
                // Using adv filter to update DS
                $scope.advFiltersAreApplied = false;


                if ($scope.simpleSearchFilter !== undefined) {
                    $scope.filter = $scope.simpleSearchFilter;
                    $scope.filtertype = 's';
                } else {
                    $scope.filter = '';
                    $scope.filtertype = 'a';
                }
                $scope.offset = 0;
                $scope.pagination.current = 1;
                $scope.applyFilterParams();

                return;
            };

            /* NOTE: these functions should not be necessary anymore
            $scope.applySimpleFilter = _.debounce($scope.updateSimpleFilter, 1200);

            $scope.validateSimpleTextFilter = function(simpleFilterText) {
                console.log("inside validate simple text");
                if (simpleFilterText === undefined) {
                    $scope.simpleSearchApplied = false;
                    return;
                }

                $scope.simpleSearchApplied = true;
                $scope.simpleSearchFilter = simpleFilterText;
                $scope.applySimpleFilter();
            };

            $scope.resetFilters = function(closeAdvancedFilter) {
                $scope.clearSimpleFilterText();
                //$scope.emptyAdvFilterDefinitions();
            };

            $scope.clearSimpleFilterText = function() {
                if ($scope.simpleSearchApplied) {
                    $scope.simpleSearchApplied = false;
                }
                if ($scope.filter !== null) {
                    $scope.filter = '';
                    $scope.offset = 0;
                    $scope.pagination.current = 1;
                    $scope.simpleSearchFilter = '';
                    $scope.simpleSearchPlaceholder = '';
                    $scope.changeReportParams();

                    // need to use jquery bnecause it wont allow $digest to update the textbox in time
                    // jQuery("#simpleChart").val('Search');
                }
            };
            */

            $scope.mappedHeaderValues = createHeaderValueToAggKeyName();
            $scope.headerNames = getDataGridHeaderValues();

            $scope.toggleFilterUsed = function() {
                $scope.advFiltersAreApplied = !$scope.advFiltersAreApplied;
                $scope.simpleSearchApplied = !$scope.simpleSearchApplied;

                $scope.initializeAdvFilterDefinitions();
                $scope.updateAdvancedFilter(true);
                $scope.applyFilterParams();
            };

            $scope.disableButton = function(index) {
                if ($scope.audio !== undefined && $scope.audio[index] !== undefined && !isNaN($scope.audio[index].duration)) {
                    return false;
                }
                return true;
            };

            $scope.playvoiceaudio = function(index, s3URL, control) {
                $scope.index = index;

                if ($scope.audio === undefined) {
                    $scope.audio = [];
                }

                if ($scope.audio[index] === undefined) {
                    $scope.audio[index] = new Audio(s3URL);
                    //add event listener for end of audio to close player when done playing
                    $scope.audio[index].addEventListener('ended', function() {
                        $scope.showme[index] = false;
                    });
                }
                var playtime;
                //pause and collapase other recordings
                for (var x in $scope.audio) {
                    //  var x = parseInt(pl);
                    if (x != index) {
                        $scope.audio[x].pause();
                        $scope.audio[x].currentTime = 0;
                        $scope.showme[x] = false;
                    }
                }
                switch (control) {

                    case 'play':
                        $scope.audio[index].play();
                        break;

                    case 'pause':
                        $scope.audio[index].pause();
                        break;

                    case 'rewind':
                        $scope.audio[index].pause();
                        playtime = $scope.audio[index].currentTime;
                        $scope.audio[index].currentTime = playtime - 10;
                        setTimeout(function() {
                            if ($scope.audio[index].currentTime < $scope.audio[index].duration)
                                $scope.audio[index].play();
                        }, 300);
                        break;

                    case 'forward':
                        $scope.audio[index].pause();
                        playtime = $scope.audio[index].currentTime;
                        $scope.audio[index].currentTime = playtime + 10;
                        setTimeout(function() {
                            if ($scope.audio[index].currentTime < $scope.audio[index].duration)
                                $scope.audio[index].play();
                        }, 300);
                        break;

                    default:
                }
            };

            //Stop all audio playback when leaving page AND destroy all event listeners.
            /*$scope.$on("$destroy", function() {
                for (var x in $scope.audio) {
                    $scope.audio[x].pause();
                }

                // Kill all event listeners on leave
                var importantListeners = ['$destroy', '$locationChangeStart', '$locationChangeSuccess'];
                for(var i in $rootScope.$$listeners) {
                    if(importantListeners.indexOf(i) === -1) {
                        delete $rootScope.$$listeners[i];
                    }
                }
            });
            */

            $scope.openEmail = function(size, s3URL) {
                $scope.s3URL = s3URL;
                var modalInstance = $uibModal.open({
                    animation: $scope.animationsEnabled,
                    templateUrl: 'assets/partials/emailCall.html',
                    controller: 'ModalInstanceCtrl',
                    size: size,
                    resolve: {
                        s3URL: function() {
                            return s3URL;
                        }
                    }
                });

                modalInstance.result.then(function(selectedItem) {
                    $scope.selected = selectedItem;
                }, function() {

                });
            };

			// ***** begin NECESSARY CODE FOR ADV FILTER TO WORK *******************
			$scope.preloading = false;
			$scope.showAdvFilter = false;
			$scope.advancedFilterConfig = { maxQuantity: 5 };

			$scope.extendUrlParams = function(urlParams) {
                if (urlParams.vars.filtertype === 's') {
                    $scope.simpleSearchFilter = urlParams.vars.filter;
                }
                $scope.urlParams = urlParams.vars;
				$scope.drp_start = moment($scope.urlParams.start_date, 'YYYY-MM-DD').format('MMMM DD, YYYY');
				$scope.drp_end = moment($scope.urlParams.end_date, 'YYYY-MM-DD').format('MMMM DD, YYYY');
                angular.extend($scope, urlParams.vars);
                delete urlParams.vars;
                angular.extend($scope, urlParams);
			};

			$scope.getInitialUrlParams = function() {
				advFilSrvc.determineInitializationMethod($scope).then(function(r) {
					console.log('INSIDE getInitialUrlParams IN callsdetails.js: Returned urlParams:', r);
					$scope.advFilterDefinitions = advFilSrvc.getAdvFilterDefinitions();
                    if ($scope.advFilterDefinitions.length > 0 && $scope.advFilterDefinitions[0].selected_column !== undefined) {
						$scope.showAdvFilter = true;
					}
					$scope.extendUrlParams(r);
					$scope.loadReportBasedOnQueryString();
				});
			}();

			$scope.addFilterDefinition = function() {
				advFilSrvc.addFilterDefinition(false);
				$scope.advFilterDefinitions = advFilSrvc.getAdvFilterDefinitions();
			};

			$scope.updateOperators = function(preloading, af, $index) {
				advFilSrvc.updateOperators(preloading, af, $index);
				$scope.advFilterDefinitions = advFilSrvc.getAdvFilterDefinitions();
			};

            $scope.applyFilterParams = function() {
                var urlParams = advFilSrvc.applyFilter($scope);
                if(urlParams) {
                	$scope.extendUrlParams(urlParams);
                    return true;
                }

                return false;
            };

			$scope.applyFilter = function() {
				$scope.horsemanFlag = false;
			$scope.audio = undefined;
				var noErrors = $scope.applyFilterParams();
                if (noErrors) {
                    $scope.loadReportBasedOnQueryString();
                }
			};

            $scope.filterReset = function() {
				advFilSrvc.resetAdvFilter();
				$scope.advFilterDefinitions = advFilSrvc.getAdvFilterDefinitions();
				$scope.showAdvFilter = false;
				$scope.simpleFilterText = '';
				$scope.filtertype = 's';
                $scope.filter = '';
                if ($scope.filterApplied) {
                    $scope.applyFilter();
                    $scope.filterApplied = false;
                }
            };

			$scope.removeFilterDefinition = function(i) {
				advFilSrvc.removeFilterDefinition(i);
				$scope.advFilterDefinitions = advFilSrvc.getAdvFilterDefinitions();
			};

			$scope.validateInput = function(e) {
				advFilSrvc.validateInput(e);
			};
			// ***** end NECESSRY CODE FOR ADV FILTER TO WORK ***************
        }
    ])
    .controller('ModalInstanceCtrl', function($scope, CallsDetailsWebService, $uibModalInstance, s3URL, pinesNotifications, $rootScope) {
        $scope.email = {
            "to": null,
            "from": "no-reply@messages.services",
            "message": null,
            "name": $rootScope.fullName,
            "s3URL": s3URL
        };

        $scope.sendEmail = function() {

        // $scope.playvoiceaudio = function(index, s3URL, control){
        //     $scope.index = index;
        //
        //     if ($scope.audio === undefined) {
        //         $scope.audio = [];
        //     }

            var emailData = {
                "email": $scope.email
            };
            //validate data
            var re = /^[_a-zA-Z0-9]+(\.[_a-zA-Z0-9]+)*@[a-zA-Z0-9-]+(\.a-zA-Z0-9-]+)*(\.[a-zA-Z]{2,4})$/;
            var valid = true;
            if (!$scope.email.to || !re.test($scope.email.to)) {
                pinesNotifications.notify({
                    title: 'Email Call Form',
                    text: 'You must enter a valid To email address',
                    type: 'error'
                });
                valid = false;
            }
            //console.log(re.test($scope.email.from));
            var re2 = /[A-Z0-9._%+-]+@[A-Z0-9.-]+.[A-Z]{2,4}/igm;
            if (!$scope.email.from || !re2.test($scope.email.from)) {
                pinesNotifications.notify({
                    title: 'Email Call Form',
                    text: 'You must enter a valid From email address',
                    type: 'error'
                });
                valid = false;

//             var playtime;
// 			//pause and collapase other recordings
// 			for(var x in $scope.audio) {
//                   //  var x = parseInt(pl);
//                 if(x != index) {
// 					$scope.audio[x].pause();
// 					$scope.audio[x].currentTime = 0;
// 					$scope.showme[x] = false;
// 				}
// 			}
//             switch(control) {
//
//                 case 'play':
//                     $scope.audio[index].play();
//                     break;
//
//                 case 'pause':
//                     $scope.audio[index].pause();
//                     break;
//
//                 case 'rewind':
//                     $scope.audio[index].pause();
//                     playtime = $scope.audio[index].currentTime;
//                     $scope.audio[index].currentTime = playtime - 10;
//                     setTimeout(function () {
//                        if($scope.audio[index].currentTime < $scope.audio[index].duration)
//                             $scope.audio[index].play();
//                     }, 300);
//                     break;
//
//                 case 'forward':
//                     $scope.audio[index].pause();
//                     playtime = $scope.audio[index].currentTime;
//                     $scope.audio[index].currentTime = playtime + 10;
//                     setTimeout(function () {
//                        if($scope.audio[index].currentTime < $scope.audio[index].duration)
//                             $scope.audio[index].play();
//                     }, 300);
//                     break;
//
//                 default:

            }
            //console.log(emailData.email.message);
            if (valid) {
                CallsDetailsWebService.emailRecording(emailData).then(function(result) {
                    //var dataSet = result.data.json;
                    //console.log(result);
                    if (result.data.err === '') {
                        pinesNotifications.notify({
                            title: 'Email Call',
                            text: 'Successfully emailed call',
                            type: 'success'
                        });
                        $uibModalInstance.close($scope.email);

                    } else {
                        pinesNotifications.notify({
                            title: 'Email Call',
                            text: 'Failed to email call',
                            type: 'error'
                        });
                    }
                });
            }
        };

        $scope.cancel = function() {
            $uibModalInstance.dismiss('cancel');
        };
    });
